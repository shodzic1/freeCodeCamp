# The Ubiquitous Binary Search

We all aware of binary search algorithm. Binary search is easiest difficult algorithm to get it right. I present some interesting problems that I collected on binary search. There were some requests on binary search.
I request you to honor the code, “I sincerely attempt to solve the problem and ensure there are no corner cases”. After reading each problem minimize the browser and try solving it.

Problem Statement: Given a sorted array of N distinct elements. Find a key in the array using least number of comparisons. (Do you think binary search is optimal to search a key in sorted array?)

Without much theory, here is typical binary search algorithm.

// Returns location of key, or -1 if not found 
int BinarySearch(int A[], int l, int r, int key) 
{ 
    int m; 
  
    while( l <= r ) 
    { 
        m = l + (r-l)/2; 
  
        if( A[m] == key ) // first comparison 
            return m; 
  
        if( A[m] < key ) // second comparison 
            l = m + 1; 
        else
            r = m - 1; 
    } 
  
    return -1; 
} 

The following implementation uses fewer number of comparisons.

// Invariant: A[l] <= key and A[r] > key 
// Boundary: |r - l| = 1 
// Input: A[l .... r-1] 
int BinarySearch(int A[], int l, int r, int key) 
{ 
    int m; 
  
    while( r - l > 1 ) 
    { 
        m = l + (r-l)/2; 
  
        if( A[m] <= key ) 
            l = m; 
        else
            r = m; 
    } 
  
    if( A[l] == key ) 
        return l; 
    else
        return -1; 
} 
In the while loop we are depending only on one comparison. The search space converges to place l and r point two different consecutive elements. We need one more comparison to trace search status.

You can see sample test case http://ideone.com/76bad0. (C++11 code)

Problem Statement: Given an array of N distinct integers, find floor value of input ‘key’. Say, A = {-1, 2, 3, 5, 6, 8, 9, 10} and key = 7, we should return 6 as outcome.

We can use the above optimized implementation to find floor value of key. We keep moving the left pointer to right most as long as the invariant holds. Eventually left pointer points an element less than or equal to key (by definition floor value). The following are possible corner cases,

—> If all elements in the array are smaller than key, left pointer moves till last element.

—> If all elements in the array are greater than key, it is an error condition.

—> If all elements in the array equal and <= key, it is worst case input to our implementation.

Here is implementation,

// largest value <= key 
// Invariant: A[l] <= key and A[r] > key 
// Boundary: |r - l| = 1 
// Input: A[l .... r-1] 
// Precondition: A[l] <= key <= A[r] 
int Floor(int A[], int l, int r, int key) 
{ 
    int m; 
  
    while( r - l > 1 ) 
    { 
        m = l + (r - l)/2; 
  
        if( A[m] <= key ) 
            l = m; 
        else
            r = m; 
    } 
  
    return A[l]; 
} 
  
// Initial call 
int Floor(int A[], int size, int key) 
{ 
    // Add error checking if key < A[0] 
    if( key < A[0] ) 
        return -1; 
  
    // Observe boundaries 
    return Floor(A, 0, size, key); 
} 
Problem Statement: Given a sorted array with possible duplicate elements. Find number of occurrences of input ‘key’ in log N time.

The idea here is finding left and right most occurrences of key in the array using binary search. We can modify floor function to trace right most occurrence and left most occurrence. Here is implementation,

// Input: Indices Range [l ... r) 
// Invariant: A[l] <= key and A[r] > key 
int GetRightPosition(int A[], int l, int r, int key) 
{ 
    int m; 
  
    while( r - l > 1 ) 
    { 
        m = l + (r - l)/2; 
  
        if( A[m] <= key ) 
            l = m; 
        else
            r = m; 
    } 
  
    return l; 
} 
  
// Input: Indices Range (l ... r] 
// Invariant: A[r] >= key and A[l] > key 
int GetLeftPosition(int A[], int l, int r, int key) 
{ 
    int m; 
  
    while( r - l > 1 ) 
    { 
        m = l + (r - l)/2; 
  
        if( A[m] >= key ) 
            r = m; 
        else
            l = m; 
    } 
  
    return r; 
} 
  
int CountOccurances(int A[], int size, int key) 
{ 
    // Observe boundary conditions 
    int left = GetLeftPosition(A, -1, size-1, key); 
    int right = GetRightPosition(A, 0, size, key); 
  
    // What if the element doesn't exists in the array? 
    // The checks helps to trace that element exists 
    return (A[left] == key && key == A[right])? 
           (right - left + 1) : 0; 
} 
